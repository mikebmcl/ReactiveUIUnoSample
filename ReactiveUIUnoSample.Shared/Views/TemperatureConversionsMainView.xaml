<Page
    x:Class="ReactiveUIUnoSample.Views.TemperatureConversionsMainView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:ReactiveUIUnoSample.Views"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vmuc="using:ReactiveUIUnoSample.ViewModels.UnitConversions"
    xmlns:vmt="using:ReactiveUIUnoSample.ViewModels.Testing"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <ScrollViewer>
        <Grid Padding="10">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <!-- Note: The following TextBlocks within the StackPanel are a demonstration of various considerations regarding fonts. The notes about each are in their AutomationProperties.Name because the StackPanel and all of its contents have nothing to do with the app itself. It is useful from a learning and an experimenting point of view to have it here. By putting the "comments" in their AutomationProperties.Name properties, it vastly simplifies commenting and uncommenting since nested comments aren't supported in any XML-based markup. The proper use of AutomationProperties.Name is to describe the control for users who are using the app with the assistance of screen reading technology. For a TextBlock, the Text itself is normally sufficiently descriptive (screen readers get the same text values that are displayed on the screen when the app is running so you don't need to worry about the fact that you will probably be using data-binding for the text of most controls). But you can override it with AutomationProperties.Name if more information is needed than the text by itself conveys. And you can bind the value for AutomationProperties.Name rather than hard-coding it. This is useful in various ways, but especially in terms of localizing your app for speakers of various languages and for users who speak the same language (though perhaps with slightly different dialects) but live in cultures where other differences exist such as currency, number formatting, different vocabulary for things that are essentially equivalent (attorney vs. solicitor + barrister), and other globalization considerations. -->
            <!--<StackPanel Grid.Row="0">
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demostrating use of a bold sans-serif font using a custom ThemeResource TextBlock Style. Note: The Style uses a FontSize of 16 which is why the remaining examples explicitly set the FontSize property to 16. This is in most cases the best way to do things. By using styles that are defined at the application level (App.xaml and any resource dictionaries included in it) and used in a consistent way (e.g. everything that's a 'sub-header' from a design point of view gets the same style), it will be much easier to create, modify, and maintain a consistent look and feel for your app. The remaining TextBlocks are, in this regard, horrible. However for this specific use they are actually preferred. These aren't meant for actual use in the app. They are simply a demonstration that explains various aspects of and potential problems with the various ways to specify fonts when styling. By putting the raw strings in the controls here we avoid the need to constantly switch back and forth between this page and the resource dictiomary. We also avoid filling up the resource dictionary with the various bad practices and erroneous values that are intentionally used here."
                           Style="{ThemeResource SansBoldBodyMediumTextBlockStyle}" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a ThemeResource to provide the FontFamily string."
                           FontFamily="{ThemeResource NotoSansBold}"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a ThemeResource to provide the FontFamily string where the FontWeight property has mistakenly not been set to Bold."
                           FontFamily="{ThemeResource NotoSansBold}"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a hard-coded FontFamily string."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Bold.ttf#Noto Sans"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a hard-coded FontFamily string where the FontWeight property has mistakenly not been set to Bold."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Bold.ttf#Noto Sans"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a hard-coded FontFamily string that includes a fallback font of the same family but a different weight (regular). The first font in the string exists in this case so the fallback is not used."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Bold.ttf#Noto Sans,ms-appx:///Assets/Fonts/NotoSans-Regular.ttf#Noto Sans"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a regular sans-serif font using a hard-coded FontFamily string that is of the same font family as the other examples that is set to use a FontWeight of Bold. In the case of this font family, the result should generally appear to be bold compared to not having FontWeight set to Bold but less bold than using the font family's bold font."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Regular.ttf#Noto Sans"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a regular sans-serif font using a hard-coded FontFamily string that is of the same font family as the other examples. The FontWeight property is not set and so it has the default value of Normal (regular and normal are different names that both equate to the same font weight; the different names are a result of legacy naming conventions). This is example exists here to show the difference between this regular version with a Normal font weight and with a Bold FontWeight as in the previous example. The previous example should appear bold compared to this."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Regular.ttf#Noto Sans"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a hard-coded FontFamily string that intentionally includes errors that cause it to refer to a font that does not exist. It includes a generic fallback family value that is the same typeface style (sans-serif) as our preferred font."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Boldx.ttf#Noto Sansx,sans-serif"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a bold sans-serif font using a hard-coded FontFamily string that intentionally includes errors that cause it to refer to a font that does not exist. It does not include a generic fallback family value (it includes no fallback at all). Without the generic fallback, if all other specified fonts are not found then the platform will use its default font. This could differ significantly from what you wanted. This is especially true on WASM, where the chosen font will depend on some combination of the client OS and the browser (it might depend on either or both). As an example, on Windows 11 using Chrome, I ended up getting Times New Roman, which is a serif font."
                           FontFamily="ms-appx:///Assets/Fonts/NotoSans-Boldx.ttf#Noto Sansx"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating use of a hard-coded font that isn't part of the project. This is generally a bad idea unless you are sure that the font will be available on all of the platforms your app is targetting. Segoe UI is only available on Windows so having it be the only font listed creates the same problems we've already discussed concerning not knowing what font you will end up with on other platforms. Similarly, the San Francisco typeface, which includes SF Pro Text, SF Pro Display, SF Mono, and New York Medium (New York * are the serif companions of the sans-serif San Francisco fonts), can only be used on Apple platforms. If you wanted to add a bit of native UI feel, including the desired variants of these fonts and other platform-specific fonts in the comma separated font list format seen earlier, with suitable fallbacks for other platforms is something to consider. The trade off is that the fonts have different metrics and so you will need to pay much closer attention to make sure that all of the text in your app is layed out in a usable and aesthetically pleasing manner."
                           FontFamily="Segoe UI"
                           FontWeight="Bold"
                           FontSize="16" />
                <TextBlock Text="Temperatures"
                           AutomationProperties.Name="Temperatures text demonstrating no FontFamily. This results in the platform using its default font. If you do not want to include a font with your app and do not want to try to specify specific fonts, you should still consider at least specifying a generic style such as serif or sans-serif so that you will have some degree of stylistic similarity across the various platforms. The best place to do this is in the Theme resource dictionaries because you can set a default style for each of the control types that will apply to all pages in the platform unless the pages or the controls within them specify something that overrides the default value. A default style is just a Style that has no Key value assigned to it. You cannot have multipe defaults for the same control in a single Xaml scope but you can set default styles within nested scopes that partially or completely override the default styles outside of that scope. For example, App.xaml's ResourceDictionary (including any that are part of it either by being in its MergedDictionaries or its ThemeDictionaries) create the application-wide scope. From there, the pages each have their own scope and the controls within a page each have their own scope and the controls within the controls... . So each page (views as we call them) can override the application's default styles with its own default styles (leaving intact any values inherited from the app's styles that it doesn't change) and the controls within the page can specify their own default styles for controls contained within them, and so on. It's best to do as much of the styling as possible in the theme dictionaries incorporated into the application's ResourceDictionary, especially anything related to colors. Something that looks good in the theme you happen to be using when testing might not look so good when you switch to a different theme. There is also consideration to be given to accessibility to make sure that your app is usable by the large number of people who use high contrast mode and those who have any of the various types of color blindness and color vision deficiency. It is also much easier for you since you (or your designer/design team) will, with rare exception, only need to make styling changes in that one centralized location rather than digging through all of the Xaml files in the app and modifying each control one by one."
                           FontWeight="Bold"
                           FontSize="16" />
            </StackPanel>-->
            <StackPanel Grid.Row="1" HorizontalAlignment="Stretch">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*" />
                        <ColumnDefinition Width="2*" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="*" />
                    </Grid.RowDefinitions>
                    <!-- Note: You need to make sure to assign a unique AutomationProperties.AutomationId value for each control you might want to test with UI testing. The compiler will not verify uniqueness for you so it's up to you. It is not recommended that you assign a value to this that is the same as the x:Name of a different control because this can result in XAML code generation conflicts on non-UWP platforms and it's possible that the x:Name for that control might end up becoming something the UI test framework will find instead of or in addition to the control you want it to find when looking for the control. See generally: https://docs.microsoft.com/en-us/dotnet/framework/ui-automation/using-ui-automation-for-automated-testing . Also: https://platform.uno/blog/an-introduction-to-unit-testing-for-uno-platform-applications/ .
                    AutomationProperties.AutomationId is bindable, which can help a lot both with maintaining unique ids and with avoiding hard-coding ids in the UI and in every UI test that uses it (including updating it in all locations if there is some need to change it). Here we use a static readonly property that is a member of the View itself which we will use in the UI tests. We're including it in the view rather than the view model because it is only relevant to this specific view and because the view model might be used for multiple views which would make maintaining automation ids there complicated as a result.
                    There are several ways to provide accessibility information for use with screen readers. You should familiarize yourself with the information, especially the Known Issues, here: https://platform.uno/docs/articles/features/working-with-accessibility.html . You should also familiarize yourself with the infromation here: https://docs.microsoft.com/en-us/windows/apps/design/accessibility/basic-accessibility-information .
                    If a control contains text, such as a TextBlock or a Button labeled using text, then that text will be picked up by a screen reader and used. If you want to override that or if the control does not include text, such as an Image, you can use AutomationProperties.Name. If there is another control that is being used as a label for that control, such as a TextBlock that contains a caption for an Image or describes the information that should be entered into a TextBox that follows it, you should instead use AutomationProperties.LabeledBy and specify the name you assigned to the control that is the label. Note that if you include both AutomationProperties.Name and AutomationProperties.LabeledBy then only the AutomationProperties.Name will be used so do not add an AutomationProperties.Name to a control that you are using AutomationProperties.LabeledBy on.
                    Ordinarily, where there is a TextBlock or other control used as a label for some other control, you should use AutomationProperties.LabeledBy with that other control since that is what someone who is not using a screen reader will see. This will also simplify localization since you will just need to have the label text be localized rather than also needing to localize the input control's AutomationProperties.Name. That said, there are situations where having an AutomationProperties.Name for the input control instead of using LabeledBy makes sense. For instance, imagine that there are two TextBox controls each with a TextBlock being used to describe what information should be entered. The first TextBox is being used to input a street address and the second one is used to enter an apartment number, floor, etc. The text in the TextBlock for the first TextBox would probably not include the fact that the next input is where the user should put an apartment number since a user who is not using a screen reader will see that there is a second TextBlock and TextBox pair for the apartment number. A user using a screen reader likely cannot see that there is a TextBox following the street address TextBox where they should put in an apartment number, etc., and the text of the label for the first TextBox does not include this fact. In this case, they would only find out about the apartment number TextBox after they entered the information in the street address TextBox and reached the TextBox for the apartment number. As a result, they might have included that information in the street address TextBox and would need to go back and re-enter the street address without the apartment number. In this situation, using AutomationProperties.Name on the street address TextBox to specify that they should enter the street address in this TextBox and that there is another TextBox coming up where they should enter an apartment number, building floor, etc. This way users using a screen reader know that they should not include that information in the street address TextBox. The TextBox for the apartment number, etc., would normally use LabeledBy unless there is some need for additional information beyond what the text in the TextBlock being used as a label for it says. -->
                    <TextBox x:Name="TempInputTextBox" Grid.Column="0" Grid.Row="1" Margin="4" AutomationProperties.AutomationId="{x:Bind local:TemperatureConversionsMainView.TempInputAutomationId}" />
                    <!-- WASM doesn't seem to like the use of DisplayMemberPath so we're using an explicit ItemTemplate instead. -->
                    <!--<ComboBox x:Name="TemperaturePickerItemsComboBox" Grid.Column="1" Grid.Row="0" Grid.RowSpan="2" Margin="4" PlaceholderText="{x:Bind ViewModel.TempPickerTitle}" DisplayMemberPath="Display" />-->
                    <ComboBox x:Name="TemperaturePickerItemsComboBox" Grid.Column="1" Grid.Row="0" Grid.RowSpan="2" Margin="4" HorizontalAlignment="Stretch" HorizontalContentAlignment="Stretch" PlaceholderText="{x:Bind ViewModel.TempPickerTitle}" AutomationProperties.AutomationId="{x:Bind local:TemperatureConversionsMainView.TempConversionTypeAutomationId}">
                        <ComboBox.ItemTemplate>
                            <DataTemplate x:DataType="vmuc:TemperatureConversionDirectionValueDisplayPair">
                                <TextBlock Text="{x:Bind Display}" />
                            </DataTemplate>
                        </ComboBox.ItemTemplate>
                    </ComboBox>
                    <TextBox x:Name="TempConversionResultTextBox" Grid.Column="2" Grid.Row="1" Margin="4" AutomationProperties.AutomationId="{x:Bind local:TemperatureConversionsMainView.TempConversionResultAutomationId}" />
                </Grid>
                <Rectangle Grid.Row="2" Grid.ColumnSpan="3" Style="{ThemeResource HorizontalAccentDividerBarRectangleStyle}" Margin="4,16,4,8" />

                <TextBlock x:Name="TempTestingHeader" Grid.Row="3" Grid.ColumnSpan="2" Margin="4,8" Text="Temperature Conversion Testing" Style="{ThemeResource SansBodyTextBlockStyle}" />

                <Grid Margin="0,4">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" MinWidth="160" />
                        <ColumnDefinition Width="Auto" MinWidth="160" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="*" />
                    </Grid.RowDefinitions>
                    <ComboBox x:Name="TempTestTypeComboBox" Grid.Row="0" Grid.Column="0" PlaceholderText="Test Type" Margin="4" HorizontalAlignment="Stretch" AutomationProperties.AutomationId="{x:Bind local:TemperatureConversionsMainView.TempTestTypeAutomationId}">
                        <ComboBox.ItemTemplate>
                            <DataTemplate x:DataType="vmuc:TemperatureConversionDirectionValueDisplayPair">
                                <TextBlock Text="{x:Bind Display}" />
                            </DataTemplate>
                        </ComboBox.ItemTemplate>
                    </ComboBox>
                    <ComboBox x:Name="TempTestDifficultyComboBox" Grid.Row="0" Grid.Column="1" PlaceholderText="Test Difficulty" Margin="4" HorizontalAlignment="Stretch" AutomationProperties.AutomationId="{x:Bind local:TemperatureConversionsMainView.TempTestDifficultyAutomationId}">
                        <ComboBox.ItemTemplate>
                            <DataTemplate x:DataType="vmt:TestDifficultyValueDisplayPair">
                                <TextBlock Text="{x:Bind Display}" />
                            </DataTemplate>
                        </ComboBox.ItemTemplate>
                    </ComboBox>
                </Grid>
                <!-- For some reason, on Android the button will not be disabled when it cannot execute if we bind it in the code-behind so we need to bind the command here. -->
                <Button x:Name="TestTemperatureConversionButton" Grid.Row="2" Grid.Column="0" Content="Begin Test" Margin="4,8" Command="{x:Bind ViewModel.RunTempTest}" AutomationProperties.AutomationId="{x:Bind local:TemperatureConversionsMainView.RunTempTestAutomationId}" />
                <!--<Button x:Name="FirstViewButton" Grid.Row="3" Grid.Column="2" Content="First View" Command="{x:Bind ViewModel.NavigateToFirstView}" />-->
                <!--</Grid>-->
            </StackPanel>
        </Grid>
    </ScrollViewer>
</Page>
